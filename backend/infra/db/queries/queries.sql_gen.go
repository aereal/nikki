// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package queries

import (
	"context"
	"strings"

	"github.com/aereal/nikki/backend/domain"
	"github.com/aereal/nikki/backend/infra/db/dto"
)

const createArticlePublications = `-- name: CreateArticlePublications :exec
insert into
  article_publications (article_id, article_revision_id, published_at)
values
  (?, ?, ?)
`

type CreateArticlePublicationsParams struct {
	ArticleID         domain.ArticleID
	ArticleRevisionID domain.ArticleRevisionID
	PublishedAt       dto.DateTime
}

func (q *Queries) CreateArticlePublications(ctx context.Context, arg CreateArticlePublicationsParams) error {
	_, err := q.db.ExecContext(ctx, createArticlePublications, arg.ArticleID, arg.ArticleRevisionID, arg.PublishedAt)
	return err
}

const createArticleRevisions = `-- name: CreateArticleRevisions :exec
insert into
  article_revisions (
    article_revision_id,
    article_id,
    title,
    body,
    authored_at
  )
values
  (?, ?, ?, ?, ?)
`

type CreateArticleRevisionsParams struct {
	ArticleRevisionID domain.ArticleRevisionID
	ArticleID         domain.ArticleID
	Title             string
	Body              string
	AuthoredAt        dto.DateTime
}

func (q *Queries) CreateArticleRevisions(ctx context.Context, arg CreateArticleRevisionsParams) error {
	_, err := q.db.ExecContext(ctx, createArticleRevisions,
		arg.ArticleRevisionID,
		arg.ArticleID,
		arg.Title,
		arg.Body,
		arg.AuthoredAt,
	)
	return err
}

const createArticles = `-- name: CreateArticles :exec
insert into
  articles (article_id, slug)
values
  (?, ?)
`

type CreateArticlesParams struct {
	ArticleID domain.ArticleID
	Slug      string
}

func (q *Queries) CreateArticles(ctx context.Context, arg CreateArticlesParams) error {
	_, err := q.db.ExecContext(ctx, createArticles, arg.ArticleID, arg.Slug)
	return err
}

const findArticleBySlug = `-- name: FindArticleBySlug :one
select
  articles.article_id,
  articles.slug,
  article_revisions.body,
  article_revisions.title,
  article_publications.published_at
from
  articles
  inner join article_revisions on article_revisions.article_id = articles.article_id
  inner join article_publications on article_publications.article_id = articles.article_id
where
  articles.slug = ?
`

type FindArticleBySlugRow struct {
	ArticleID   domain.ArticleID
	Slug        string
	Body        string
	Title       string
	PublishedAt dto.DateTime
}

func (q *Queries) FindArticleBySlug(ctx context.Context, slug string) (*FindArticleBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, findArticleBySlug, slug)
	var i FindArticleBySlugRow
	err := row.Scan(
		&i.ArticleID,
		&i.Slug,
		&i.Body,
		&i.Title,
		&i.PublishedAt,
	)
	return &i, err
}

const findCategoriesByNames = `-- name: FindCategoriesByNames :many
select
  category_id, name
from
  categories
where
  name in (/*SLICE:names*/?)
`

func (q *Queries) FindCategoriesByNames(ctx context.Context, names []string) ([]*Category, error) {
	query := findCategoriesByNames
	var queryParams []interface{}
	if len(names) > 0 {
		for _, v := range names {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:names*/?", strings.Repeat(",?", len(names))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:names*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.CategoryID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const importCategories = `-- name: ImportCategories :exec
insert into
  categories (category_id, name)
values
  (?, ?) on conflict (name) do nothing
`

type ImportCategoriesParams struct {
	CategoryID domain.CategoryID
	Name       string
}

func (q *Queries) ImportCategories(ctx context.Context, arg ImportCategoriesParams) error {
	_, err := q.db.ExecContext(ctx, importCategories, arg.CategoryID, arg.Name)
	return err
}

const mapArticleCategory = `-- name: MapArticleCategory :exec
insert into
  article_category_mappings (article_id, category_id)
values
  (?, ?)
`

type MapArticleCategoryParams struct {
	ArticleID  domain.ArticleID
	CategoryID domain.CategoryID
}

func (q *Queries) MapArticleCategory(ctx context.Context, arg MapArticleCategoryParams) error {
	_, err := q.db.ExecContext(ctx, mapArticleCategory, arg.ArticleID, arg.CategoryID)
	return err
}
