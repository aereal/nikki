// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package queries

import (
	"context"
	"fmt"
	"reflect"
	"strings"
)

func extractFieldValues[T any](args []T, paramFieldNames []string) ([]any, error) {
	values := make([]any, 0, len(args)*len(paramFieldNames))
	if len(paramFieldNames) == 0 {
		return values, nil
	}

	for i, arg := range args {
		rv := reflect.ValueOf(arg)
		if rv.Kind() == reflect.Ptr {
			rv = rv.Elem()
		}

		if rv.Kind() != reflect.Struct {
			return nil, fmt.Errorf("args[%d] (type %T) is not a struct or pointer to struct", i, arg)
		}

		for _, fieldName := range paramFieldNames {
			field := rv.FieldByName(fieldName)
			if !field.IsValid() {
				return nil, fmt.Errorf("args[%d] (type %T): field '%s' not found", i, arg, fieldName)
			}
			if !field.CanInterface() {
				return nil, fmt.Errorf("args[%d] (type %T): field '%s' cannot be interfaced (not exported or unaddressable)",
					i, arg, fieldName)
			}
			values = append(values, field.Interface())
		}
	}
	return values, nil
}

func buildBulkInsertQuery(originalQuery string, numArgs int, numParamsPerArg int) (string, error) {
	if numArgs == 0 {
		return "", fmt.Errorf("number of arguments (rows) for bulk insert cannot be zero")
	}
	if numParamsPerArg == 0 {
		return "", fmt.Errorf("number of parameters per argument (columns) for bulk insert cannot be zero")
	}

	// Extract the "INSERT INTO table (col1, col2) VALUES " part from the original query
	// First, remove the trailing semicolon, if any
	trimmedQuery := strings.TrimSpace(originalQuery)
	if strings.HasSuffix(trimmedQuery, ";") {
		trimmedQuery = trimmedQuery[:len(trimmedQuery)-1]
	}

	// search "VALUES" (case insensitive)
	valuesUpperIndex := strings.LastIndex(strings.ToUpper(trimmedQuery), "VALUES")
	if valuesUpperIndex == -1 {
		return "", fmt.Errorf("invalid query format: VALUES clause not found in original query: %s", originalQuery)
	}

	// Prefix the query up to "VALUES".
	// (e.g., "INSERT INTO users (id, name)")
	// Add "VALUES" to this
	queryPrefixStr := strings.TrimSpace(trimmedQuery[:valuesUpperIndex]) + " VALUES "

	// Find the suffix of the query (e.g., "ON DUPLICATE KEY UPDATE ...")
	// The suffix starts after the original placeholder, e.g., after `VALUES (?, ?)`
	var querySuffixStr string
	// Start searching after the "VALUES" keyword
	searchStartIndex := valuesUpperIndex + len("VALUES")
	// Find the first closing parenthesis ')' after the "VALUES" clause
	firstClosingParenIndex := strings.Index(trimmedQuery[searchStartIndex:], ")")

	if firstClosingParenIndex != -1 {
		// The suffix is the part of the string after the closing parenthesis.
		// We add 1 to skip the ')' character itself.
		suffixStartIndex := searchStartIndex + firstClosingParenIndex + 1
		if suffixStartIndex < len(trimmedQuery) {
			querySuffixStr = " " + strings.TrimSpace(trimmedQuery[suffixStartIndex:])
		}
	}

	var queryBuilder strings.Builder
	queryBuilder.WriteString(queryPrefixStr)

	valueStrings := make([]string, numArgs)
	for i := 0; i < numArgs; i++ {
		placeholders := make([]string, numParamsPerArg)
		for j := 0; j < numParamsPerArg; j++ {
			placeholders[j] = "?"
		}
		valueStrings[i] = fmt.Sprintf("(%s)", strings.Join(placeholders, ","))
	}
	queryBuilder.WriteString(strings.Join(valueStrings, ","))

	// Append the suffix if it exists.
	if querySuffixStr != "" {
		queryBuilder.WriteString(querySuffixStr)
	}

	return strings.TrimSpace(queryBuilder.String()), nil
}

// BulkImportCategoriesParams is a slice type of ImportCategoriesParams.
// The ImportCategoriesParams type is assumed to be generated by sqlc based on the original ImportCategories query.
type BulkImportCategoriesParams []ImportCategoriesParams

// BulkImportCategories executes a bulk insert with the specified argument slice.
func (q *Queries) BulkImportCategories(ctx context.Context, args BulkImportCategoriesParams) error {
	if len(args) == 0 {
		return nil
	}

	// Query string constant name generated by the original sqlc
	originalQuery := importCategories

	// Define this as a variable in the Go code
	paramFieldNamesForQuery := []string{"CategoryID", "Name"}

	bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
	if err != nil {
		return fmt.Errorf("failed to build bulk insert query for ImportCategories: %w", err)
	}

	preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
	if err != nil {
		return fmt.Errorf("failed to extract field values for ImportCategories: %w", err)
	}

	if q.db == nil {
		return fmt.Errorf("Queries.db is nil")
	}
	_, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
	return err
}

// BulkCreateArticlesParams is a slice type of CreateArticlesParams.
// The CreateArticlesParams type is assumed to be generated by sqlc based on the original CreateArticles query.
type BulkCreateArticlesParams []CreateArticlesParams

// BulkCreateArticles executes a bulk insert with the specified argument slice.
func (q *Queries) BulkCreateArticles(ctx context.Context, args BulkCreateArticlesParams) error {
	if len(args) == 0 {
		return nil
	}

	// Query string constant name generated by the original sqlc
	originalQuery := createArticles

	// Define this as a variable in the Go code
	paramFieldNamesForQuery := []string{"ArticleID", "Slug"}

	bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
	if err != nil {
		return fmt.Errorf("failed to build bulk insert query for CreateArticles: %w", err)
	}

	preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
	if err != nil {
		return fmt.Errorf("failed to extract field values for CreateArticles: %w", err)
	}

	if q.db == nil {
		return fmt.Errorf("Queries.db is nil")
	}
	_, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
	return err
}

// BulkCreateArticleRevisionsParams is a slice type of CreateArticleRevisionsParams.
// The CreateArticleRevisionsParams type is assumed to be generated by sqlc based on the original CreateArticleRevisions query.
type BulkCreateArticleRevisionsParams []CreateArticleRevisionsParams

// BulkCreateArticleRevisions executes a bulk insert with the specified argument slice.
func (q *Queries) BulkCreateArticleRevisions(ctx context.Context, args BulkCreateArticleRevisionsParams) error {
	if len(args) == 0 {
		return nil
	}

	// Query string constant name generated by the original sqlc
	originalQuery := createArticleRevisions

	// Define this as a variable in the Go code
	paramFieldNamesForQuery := []string{"ArticleRevisionID", "ArticleID", "Title", "Body", "AuthoredAt"}

	bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
	if err != nil {
		return fmt.Errorf("failed to build bulk insert query for CreateArticleRevisions: %w", err)
	}

	preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
	if err != nil {
		return fmt.Errorf("failed to extract field values for CreateArticleRevisions: %w", err)
	}

	if q.db == nil {
		return fmt.Errorf("Queries.db is nil")
	}
	_, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
	return err
}

// BulkCreateArticlePublicationsParams is a slice type of CreateArticlePublicationsParams.
// The CreateArticlePublicationsParams type is assumed to be generated by sqlc based on the original CreateArticlePublications query.
type BulkCreateArticlePublicationsParams []CreateArticlePublicationsParams

// BulkCreateArticlePublications executes a bulk insert with the specified argument slice.
func (q *Queries) BulkCreateArticlePublications(ctx context.Context, args BulkCreateArticlePublicationsParams) error {
	if len(args) == 0 {
		return nil
	}

	// Query string constant name generated by the original sqlc
	originalQuery := createArticlePublications

	// Define this as a variable in the Go code
	paramFieldNamesForQuery := []string{"ArticleID", "ArticleRevisionID", "PublishedAt"}

	bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
	if err != nil {
		return fmt.Errorf("failed to build bulk insert query for CreateArticlePublications: %w", err)
	}

	preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
	if err != nil {
		return fmt.Errorf("failed to extract field values for CreateArticlePublications: %w", err)
	}

	if q.db == nil {
		return fmt.Errorf("Queries.db is nil")
	}
	_, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
	return err
}

// BulkMapArticleCategoryParams is a slice type of MapArticleCategoryParams.
// The MapArticleCategoryParams type is assumed to be generated by sqlc based on the original MapArticleCategory query.
type BulkMapArticleCategoryParams []MapArticleCategoryParams

// BulkMapArticleCategory executes a bulk insert with the specified argument slice.
func (q *Queries) BulkMapArticleCategory(ctx context.Context, args BulkMapArticleCategoryParams) error {
	if len(args) == 0 {
		return nil
	}

	// Query string constant name generated by the original sqlc
	originalQuery := mapArticleCategory

	// Define this as a variable in the Go code
	paramFieldNamesForQuery := []string{"ArticleID", "CategoryID"}

	bulkSQL, err := buildBulkInsertQuery(originalQuery, len(args), len(paramFieldNamesForQuery))
	if err != nil {
		return fmt.Errorf("failed to build bulk insert query for MapArticleCategory: %w", err)
	}

	preparedValues, err := extractFieldValues(args, paramFieldNamesForQuery)
	if err != nil {
		return fmt.Errorf("failed to extract field values for MapArticleCategory: %w", err)
	}

	if q.db == nil {
		return fmt.Errorf("Queries.db is nil")
	}
	_, err = q.db.ExecContext(ctx, bulkSQL, preparedValues...)
	return err
}
